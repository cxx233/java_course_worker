

[toc]





# 服务器通信原理

## <a id = "原理图"> 原理图 </a >

![image-20220305220538442](socket编程.assets/image-20220305220538442.png)

首先要明白端口的作用以及意义：

每个服务契都有很多进程，所有的进程都会复用同一个网络同一块网卡跟外面其他所有的辑器打交道。=》 怎么判断这次收发的数据是这个进程所需要的数据。=》 依赖：IP+ 端口。

（IP： 一栋楼地址，端口：楼上具体的几层几号）

每个进程相当于 用户，把自己绑定一个门牌号。

1024 默认保留，不适合用户使用。



## 实现Http 服务器 

使用压测工具



处理过程

> 单线程处理 socket 》 每个请求一个线程
>
> 》 固定大小线程池处理





# I/O 通信 

## <a href="原理图"> 原理图</a> 过程分析

通信 过程，两种类型操作

> - CPU 计算/业务处理
> - IO 操作与等待/网络、磁盘、数据库



存在CPU 使用率低

![image-20220315160401296](socket编程.assets/image-20220315160401296.png)



### 解决方案

> 统筹学





### 底层问题

socket 通信过程，现在在内核空间存在有个<a id="缓冲区">缓冲区</a>（存网卡数据），然后再在用户空间进行cv 处理，如下图：

![image-20220315161825385](socket编程.assets/image-20220315161825385.png)



#### 优化方案：

> 1.  缓冲区 只用一块，不用再拷贝 = epoll
> 2. 线程：单线程永远不是最优的（I/O、CPU 都要他处理）
> 3. 流水线处理：把I/O 过程拆分不同步骤（每个步骤由一个线程池处理）





# NIO 模型与相关概念

- 同步、异步 =》 **通信模式** (TODO 待补充？双工、半双工、全工)
- 阻塞、非阻塞 =》 线程处理模式



## 五种I/O 模型

![image-20220315165952054](socket编程.assets/image-20220315165952054.png)



### 阻塞式IO => BIO

![image-20220315170140481](socket编程.assets/image-20220315170140481.png)

注意事项

> 1. 需要等待内核把数据准备好
> 2. 准备好后，用户空间 将 上面的 “<a href="缓冲区">缓冲区</a>”进行cv
> 3. 业务线程处理数据报文



#### 时序图

![image-20220315170507347](socket编程.assets/image-20220315170507347.png)

解读：

> 内核等待数据到达后，并将数据写入到内核，然后会唤醒业务线程， 业务线程就拷贝到自己空间