

# GC 与堆的总结



## 1. 串行GC 

串行GC 特点

> - 年轻代：mark-copy  标记复制算法
> - 老年代：mark-sweep-compact 标记-清楚-整理
>
> 采用的单线程的垃圾收集器 =》 触发 STW
>
> 

串行GC 与堆的关系

> 1、由于是串行关系，并且是单线程，对于堆配置越大，一旦需要执行GC 的时候，那么STW 时间越长。
>
> 2、堆越大，GC 年轻代的eden 区和老年代 存储的数据越大，存储的对象也可以越多。执行频率比堆小的更少。







## 2. 并行GC

并行GC 特点

> 在串行GC的基础上（年轻代、老年代 执行的回收算法相同的基础上）
>
> 1. 对于年轻代、老年代 执行回收算法 都是使用多线程的执行的。
> 2. 即使是多线程情况，但并行GC 还是会停业务线程，让进行STW 。
> 3. 但相比串行而言，STW  时间相对较少。

并行GC 目标：

> 添加吞吐量



GC 与堆

> 1、堆越大，GC 年轻代的eden 区和老年代 存储的数据越大，存储的对象也可以越多。GC执行频率比堆小的更少。
>
> （适用范畴：64位机器，小于4G 的内存，由于指针压缩。所以这里堆可以保存更多数据。）



## 3. CMS GC

CMS GC 特点

> - 年轻代：采用并行STW 的mark-copy（标记-复制算法）
>   - =》 会STW，GC 线程与业务线程并不能同时执行，但由于年轻代使用多GC线程执行快，STW 并不明显。
> - 老年代：并发标记- 清除（mark-sweep） 。主要分为六个阶段
>   - 阶段1：Initial Mark（初始标记） ：会有STW，也就是说：GC 线程与业务线程不可同时进行。但也是会使用多线程，所以相对快一点。
>   - 阶段2：Concurrent Mark（并发标记）： 标记存活对象；与业务线程同时运行 =》并发处理
>   - 阶段3： Concurrent Preclean（并发预处理）：与业务线程同时运行 =》 并发处理
>   - 阶段3.1： 
>   - 阶段4：Final Remark(最终标记)：进行一次短暂的STW 
>     - 上个阶段并发处理，会存在对象应用关系发生变化 =》 进行STW 标记所阶段 =》 脏的区域理清=》 标记引用关系明确
>     - 注意：CMS 在Young 区尽量空的情况执行，因为young 区使用的是并行的 STW 的算法，少的花，避免出发多次STW 事件。
>   - 阶段5：Concurrent Sweep(并发清理)：GC 线程与业务线程并发处理
>   - 阶段6：Concurrent Reset（并发重置）：GC 线程与业务线程并发处理



GC 与堆关系暂时看不出

## 4. G1 GC

G1 GC 特点

> 与前面GC 不同，这里是按照region 进行划分内存（堆）。每个region 均可划分（指定）不同的区 Eden, Survivor、Old 区。
>
> 逻辑：
>
> - 年轻代：所有Eden 区+ Survivor
>
> - 老年代：数Old region



G1 GC 与堆关系

> 系统堆较大，整体平均GC 时间可控，使用G1 GC
>
> 

